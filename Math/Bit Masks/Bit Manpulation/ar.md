# التلاعب بالبتات

## المقدمة
يشير التلاعب بالبتات إلى إجراء العمليات مباشرة على التمثيلات الثنائية للأعداد الصحيحة. في البرمجة التنافسية، غالبًا ما تؤدي حيل البت إلى حلول بوقت $O(1)$ لمسائل تتعلق بالمجاميع الجزئية، وفحص الزوجية، واختبارات كون العدد قوة للعدد 2، والمزيد.

## التمثيل الثنائي

يمكن تمثيل كل عددٍ صحيح غير سالب كسلسلة من البتات (0 و1). فمثلاً، للعدد غير المُوقع بعرض 32-بت $x$ تمثيل ثنائي:

$$
 x = b_{31}2^{31} + b_{30}2^{30} + \dots + b_1 2^1 + b_0 2^0,
 \quad b_i \in \{0,1\}.
$$

حيث:
- $b_i = 1$ يعني أن البت في الموضع $i$ (بدءًا من الصغير وهو 0) مرفوع.
- يُكتب التمثيل غالبًا كسلسلة بعرض ثابت، مثلاً $x=13$ يصبح $000\,00000\,00001101_2$ في عرض 16-بت.

للأعداد الموقعة يُستخدم تمثيل «المكمّل إلى اثنين» (two's complement): البت الأكثر دلالة يمثل الإشارة، والعدد السالب $-y$ يُمثَّل كـ $2^n - y$ في عمليَّات بعرض $n$-بت.

## العمليات على مستوى البت
- **العملية وَ** (`&`): تحتفظ بالبتات التي تكون 1 في كلا المعاملين.  
  مثال: `5 & 3 = 1` ($101_2 & 011_2 = 001_2$).
- **العملية أَو** (`|`): ترفع البت الذي يكون 1 في أيٍ من المعاملين.  
  مثال: `5 | 3 = 7` ($101_2 | 011_2 = 111_2$).
- **العملية الأَو الحصري (XOR)** (`^`): ترفع البت الذي يختلف بين المعاملين.  
  مثال: `5 ^ 3 = 6` ($101_2 \oplus 011_2 = 110_2$).
- **عملية النفي** (`~`): تقلب كل البتات (في تمثيل المكمّل إلى اثنين).  
  مثال: `~5 = -6` ($~101_2 = \dots111010_2$).
- **الإزاحة لليسار** (`<<`): تحرك البتات إلى اليسار، وتملأ بالصفر على اليمين، معادلةً ضربًا في قوة للعدد 2:  
  $x << k = x \times 2^k$.
- **الإزاحة لليمين** (`>>`): تحرك البتات إلى اليمين؛ في الأعداد غير الموقعة يملأ بصفر، وفي الموقعة غالبًا يُملأ بالبت الأكثر دلالة (arithmetic shift):  
  $x >> k = \lfloor x / 2^k\rfloor$.

## الحيل الشائعة

### استخراج أقل بت مرفوع
=== "c++"

```cpp
int lowbit(int x) {
    return x & -x;
}
```
يعتمد على حقيقة أن $-x = \overline{x} + 1$.  
وبالتالي: $
  \text{lowbit}(x) = x & (-x).
$

### إزالة أقل بت مرفوع
=== "c++"

```cpp
x &= (x - 1);
```
تزيل أقل بت مرفوع من العدد.  
إذا كان $x > 0$، فإن $x & (x - 1)$ يمحُو البت الأيمن `1`.

### التحقق من كون العدد قوة للعدد 2
=== "c++"

```cpp
bool isPowerOfTwo(int x) {
    return x > 0 && (x & (x - 1)) == 0;
}
```
العدد قوة للعدد 2 إذا وفقط إذا كان يحتوي على بت واحد مرفوع فقط.  
أي: $x > 0$ و$x & (x - 1) = 0$.

### عدّ البتات (عدد المرفوعات)
استخدام الدوال المدمجة في GCC:
=== "c++"

```cpp
int cnt = __builtin_popcount(x);       // للأعداد 32-بت
int cnt64 = __builtin_popcountll(x);  // للأعداد 64-بت
```
زمن التنفيذ ثابت $O(1)$.

## التكرار عبر جميع المجموعات الجزئية

لمجموعةٍ مكوَّنة من $n$ عناصر، نرمز لها من 0 إلى $n-1$. كل مجموعة جزئية تمثّلها قناع بت $m$ يتراوح من 0 حتى $2^n - 1$:
=== "c++"

```cpp
int total = 1 << n;
for (int mask = 0; mask < total; ++mask) {
    vector<int> subset;
    for (int i = 0; i < n; ++i) {
        if (mask & (1 << i))
            subset.push_back(i);
    }
    // معالجة المجموعة الجزئية
}
```
يستغرق هذا $O(n2^n)$ عبر جميع المجموعات $2^n$.

## التطبيقات في البرمجة التنافسية
- **البرمجة الديناميكية بقناع البت (Bitmask DP)**: حالات تُشفَّر بأقنعة، مثل مشكلة TSP بزمن $O(n^2 2^n)$.
- **تعداد المجموعات الجزئية**: meet-in-the-middle، وSOS DP.
- **فحص الزوجية والإشارات**: حساب زوجية عدد البتات عبر XOR.
- **العمليات السريعة**: التحقق من زوجية/فردية، وباقي القسمة على قوة 2:  $x \bmod 2^k = x & (2^k - 1)$.

## الدوال المدمجة في C++ للبتات

يوفر C++ مجموعة من الدوال المدمجة لعمليات شائعة على البت، تعمل كلها بزمن ثابت غالبًا.

### عدّ البتات وزوجيتها
- `int cnt = __builtin_popcount(x);` // عدد البتات 1 في عدد 32-بت.
- `int cnt64 = __builtin_popcountll(x);` // عدد البتات 1 في عدد 64-بت.
- `int pr = __builtin_parity(x);` // زوجية مجموع البتات (0 أو 1).

### عدّ الأصفار المتقدمة والمتأخرة
- `int lz = __builtin_clz(x);` // عدد الأصفار المتقدمة في 32-بت (غير معرّف إذا كان x==0).
- `int lz64 = __builtin_clzll(x);` // عدد الأصفار المتقدمة في 64-بت.
- `int tz = __builtin_ctz(x);` // عدد الأصفار المتأخرة في 32-بت (غير معرّف إذا كان x==0).
- `int tz64 = __builtin_ctzll(x);` // عدد الأصفار المتأخرة في 64-بت.

### إيجاد أول بت مرفوع
- `int f = __builtin_ffs(x);` // مؤشر (واحد-مبني على الواحد) لأقل بت 1 مرفوع، أو 0 إذا كان x==0.

هذه الدوال مفيدة للاستعلامات السريعة على مستوى البت، ومدعومة في GCC وClang ومعظم المترجمات المتوافقة.

## الأداء وأفضل الممارسات
- جميع العمليات الأساسية (`&`, `|`, `^`, `~`, `<<`, `>>`) تعمل في $O(1)$.
- استخدم الدوال المدمجة لعدّ البتات وclz (عد الأصفار المتقدمة):  
=== "c++"

  ```cpp
  int leading = __builtin_clz(x);
  ```
- تجنّب الاعتماد على سلوك الإزاحة لليمين للأنواع الموقعة بين المترجمات.

## الخلاصة
يوفر التلاعب بالبتات حلولًا أنيقة وزمنية ثابتة للعديد من المسائل. إتقان هذه الحيل يعزز سرعة التنفيذ ويقلل من التعقيد الزمني في البرمجة التنافسية.
