# مقدمة في نظرية الأعداد

**نظرية الأعداد** هي فرع من فروع الرياضيات يُعنى بدراسة الأعداد الصحيحة والعلاقات بينها.  
تبدأ بمفاهيم بسيطة مثل القابلية للقسمة والأعداد الأولية، لكنها تؤدي إلى تقنيات قوية تُستخدم في مجالات مثل التشفير، والخوارزميات، وعلوم الحاسوب.

---

## القابلية للقسمة

المفهوم الأساسي في نظرية الأعداد هو **القابلية للقسمة**.

لننظر إلى مجموعة الأعداد الصحيحة $\mathbb{Z} = \{\dots, -2, -1, 0, 1, 2, \dots \}$.  
بالنسبة إلى $a, b \in \mathbb{Z}$، نقول إن $a$ **يَقسِم** $b$ إذا وُجد عدد صحيح $x \in \mathbb{Z}$ بحيث $a \cdot x = b$.

إذا كان $a$ يقسم $b$ نكتب: $a \mid b$، ونقول إن $a$ هو **قاسم** لـ $b$، أو أن $b$ هو **مضاعف** لـ $a$، أو أن $b$ **قابل للقسمة على** $a$.

وإذا لم يكن $a$ يقسم $b$، نكتب: $a \nmid b$.

### مبرهنة

لكل $a, b, c \in \mathbb{Z}$، لدينا:

- $a \mid a$, $1 \mid a$, و $a \mid 0$.
- $a \mid b$ **إذا وفقط إذا** $-a \mid b$ **وإذا وفقط إذا** $a \mid -b$.
- إذا كان $a \mid b$ و $a \mid c$، فإن $a \mid (b + c)$.
- إذا كان $a \mid b$ و $b \mid c$، فإن $a \mid c$.
- $a \mid b$ و $b \mid a$ **إذا وفقط إذا** $a = \pm b$.

## ما هو المودولو (باقي القسمة)؟

نتيجة **عملية المودولو** هي **الباقي** عند قسمة عدد على عدد آخر.

في **الرياضيات**، تُكتب العملية على النحو التالي:

$$
a \bmod b
$$

وتُقرأ: "**a مود b**".

أما في **البرمجة**، فعادةً ما يُمثَّل المودولو باستخدام رمز النسبة المئوية $%$، وتُكتب على الشكل:

```cpp
a % b
```

### العلاقة مع القسمة الصحيحة:

عند قسمة عدد صحيح $a$ على عدد صحيح $b$، نحصل على نتيجتين:

- **ناتج القسمة** (quotient): كم مرة يحتوي $b$ على $a$.
- **الباقي** (remainder): ما يتبقى بعد طرح $b \times \text{ناتج القسمة}$ من $a$.

عملية المودولو تُعيد فقط **الباقي** من هذه القسمة.


### مثال:

- $14 \bmod 3 = 2$ $\rightarrow$ لأن $14 \div 3 = 4$ والباقي $2$.
- $12 \bmod 4 = 0$ $\rightarrow$ لأن $12$ يقبل القسمة على $4$ تمامًا.
- $7 \bmod 7 = 0$ $\rightarrow$ لأن كل عدد يقسم نفسه.

عملية المودولو تُعد من الأدوات الأساسية في نظرية الأعداد.  
ويمكن استخدامها للتحقق مما إذا كان $a$ يقسم $b$ من خلال التحقق مما إذا كان $b \equiv 0 \pmod{a}$  
أو برمجياً:  `(b % a == 0)`.


---

### التمهيد لتدوين التطابق (Congruence)

في نظرية الأعداد، غالبًا ما نُعبّر عن علاقات المودولو بشكل أكثر رسمية باستخدام **تدوين التطابق** (Congruence Notation).

> يُقال إن عددين صحيحين $a$ و $b$ هما **متطابقان بترديد $m$** إذا كان لهما نفس الباقي عند القسمة على $m$.

بصيغة رياضية:

$$
a \equiv b \pmod{m} \Leftrightarrow (a - b) \text{ قابل للقسمة على } m \Leftrightarrow a \bmod m = b \bmod m
$$

---

### أمثلة:

- $14 \equiv 2 \pmod{3}$ $\rightarrow$ لأن كلاً من $14$ و $2$ لهما نفس الباقي $2$ عند القسمة على $3$.
- $38 \equiv 2 \pmod{6}$ $\rightarrow$ لأن $38 - 2 = 36$، و $36$ يقبل القسمة على $6$.
- $7 \equiv 0 \pmod{7}$ $\rightarrow$ لأن أي عدد يقبل القسمة على نفسه.

---

هذه العلاقة التطابقية تساعدنا على التفكير في مسائل القابلية للقسمة و**فئات التكافؤ** ضمن ترديد معين.  
وهي تشكّل الأساس للحسابات في **الحساب المعياري** (modular arithmetic)، والذي يُتيح لنا إجراء العمليات مثل الجمع، والطرح، والضرب، وحتى رفع القوى **بترديد $m$**.


---

## القواسم (Divisors)

ليكن $d$ و $n$ عددين صحيحين موجبَين.

> نقول إن $d$ هو **قاسم** للعدد $n$ إذا وُجد عدد صحيح $k$ بحيث $n = d \times k$.

بعبارة أخرى، $d$ يقسم $n$ **بشكل كامل** — أي **بدون باقٍ**.  
وهذا يُعادل رياضيًا أن:

$$
n \bmod d = 0
$$

كل عدد صحيح موجب $n$ له على الأقل قاسمان: $1$ و $n$ نفسه.  
وغالبًا ما نهتم بإيجاد **جميع القواسم** الممكنة لعدد معين $n$.

---

### الهدف: إيجاد جميع القواسم لـ $n$

نريد طريقة تُعطينا **كل الأعداد** التي تقسم العدد $n$.

---

### خوارزمية القواسم البسيطة – $O(n)$

#### الخوارزمية (بصيغة شبه كود):

```plaintext
For each number i from 1 to n:
    If n divided by i has no remainder:
        Then i is a divisor of n → add it to the list
```

This method checks **every number** up to $n$.

---

#### التنفيذ

=== "c++"
```cpp
#include <vector>
using namespace std;

// Naive method: try all i from 1 to n and check if n % i == 0
vector<int> findDivisorsNaive(int n) {
    vector<int> divisors;

    for (int i = 1; i <= n; ++i) {
        if (n % i == 0) {
            // i is a divisor if it divides n with no remainder
            divisors.push_back(i);
        }
    }

    return divisors;
}
```

=== "Python"
```python
def find_divisors_naive(n):
    divisors = []

    for i in range(1, n + 1):
        if n % i == 0:
            # i is a divisor if it divides n with no remainder
            divisors.append(i)

    return divisors
```

هذه الطريقة مناسبة عندما يكون $n$ صغيرًا، لكنها تصبح غير فعالة مع الأعداد الكبيرة — لأنها تقوم بـ **$n$ عملية فحص**.

---

### كيف تأتي القواسم في أزواج

ليكن $n$ عددًا صحيحًا موجبًا. يُقال إن عددًا $d$ هو **قاسم** لـ $n$ إذا وُجد عدد صحيح $k$ بحيث:

$$
n = d \times k
$$

في هذه الحالة، كل من $d$ و $k$ يعتبران قواسم لـ $n$، لأن حاصل ضربهما يعطي $n$.  
وهذا يدل مباشرةً على أن **القواسم تأتي في أزواج**: إذا كان $d \mid n$، فإن $\frac{n}{d} \mid n$ كذلك.

يمكننا التفكير في كل قاسم $d$ بأنه مقترن مع قاسم آخر $\frac{n}{d}$.  
وبالتالي، يمكن جمع كل القواسم الممكنة لـ $n$ في أزواج من الشكل **($d$, $\frac{n}{d}$)**.

---

### لماذا يكفي التحقق حتى $\sqrt{n}$ فقط

الآن نطرح سؤالًا: كم عدد القيم من $d$ نحتاج لفحصها لإيجاد جميع القواسم؟

لننظر إلى عددين $a$ و $b$ بحيث:

$$
a \times b = n
$$

ندّعي أن **واحدًا على الأقل من العددين $a$ أو $b$ يجب أن يكون أقل من أو يساوي $\sqrt{n}$**.

#### البرهان:

نفترض على سبيل التناقض أن كلًا من $a > \sqrt{n}$ و $b > \sqrt{n}$.  
عندها يكون حاصل ضربهما:

$$
a \times b > \sqrt{n} \times \sqrt{n} = n
$$

لكن هذا يُخالف الفرض أن $a \times b = n$.  
إذًا، من **المستحيل أن يكون كلٌ من $a$ و $b$ أكبر من $\sqrt{n}$** إذا كان حاصل ضربهما $n$.

لذلك، في كل زوج من القواسم $(d, \frac{n}{d})$، يوجد عدد واحد على الأقل $\le \sqrt{n}$.  
وهذا يعني:

> لإيجاد جميع القواسم لـ $n$، يكفي التحقق من القواسم $d$ في النطاق $1 \le d \le \sqrt{n}$  
> وإذا تحققنا من أن $d$ يقسم $n$، فإن $\frac{n}{d}$ يكون تلقائيًا قاسمًا أيضًا.

---

#### مثال:

لنفترض أن $n = 36$

إذا تحققنا من الأعداد من $1$ إلى $6$ (لأن $\sqrt{36} = 6$)، نجد:
- $1$ $\leftarrow$ زوجها هو $36$
- $2$ $\leftarrow$ زوجها هو $18$
- $3$ $\leftarrow$ زوجها هو $12$
- $4$ $\leftarrow$ زوجها هو $9$
- $6$ $\leftarrow$ زوجها هو $6$ (نعده مرة واحدة فقط)

كل القواسم الأكبر من $6$ هي فقط ناتجة من $\frac{n}{d}$ لأحد القواسم الأصغر.

وهذا ما يجعل التحقق حتى $\sqrt{n}$ ليس كافيًا فقط، بل هو **الحل الأمثل**.


### خوارزمية القواسم المحسّنة – $O(\sqrt{n})$

باستخدام المعلومة السابقة، يمكننا تقليل عدد العمليات.  
نقوم فقط بالتكرار حتى $\sqrt{n}$، ولكل قاسم $i$ نضيف كلًا من $i$ و $\frac{n}{i}$.

---

#### شبه كود:

```plaintext
For each number i from 1 to sqrt(n):
    If n is divisible by i:
        Add i to the list
        If n / i is different from i:
            Add n / i to the list
```

This way, we get both the small and large divisors efficiently.

---

#### التنفيذ

=== "c++"
```cpp
#include <vector>
#include <cmath>
using namespace std;

// Optimized method: only check up to sqrt(n), and use divisor pairs
vector<int> findDivisors(int n) {
    vector<int> divisors;

    for (int i = 1; i * i <= n; ++i) {
        if (n % i == 0) {
            divisors.push_back(i);           // i is a divisor
            if (i != n / i) {
                divisors.push_back(n / i);   // n / i is the paired divisor
            }
        }
    }

    return divisors;
}
```

=== "Python"
```python
import math

def find_divisors(n):
    divisors = []

    for i in range(1, int(math.isqrt(n)) + 1):
        if n % i == 0:
            divisors.append(i)           # i is a divisor
            if i != n // i:
                divisors.append(n // i)  # n // i is the paired divisor

    return divisors
```

هذه الطريقة تُقلل التعقيد الزمني من **$O(n)$** إلى **$O(\sqrt{n})$**، وتُعد الطريقة المعيارية في أغلب مسائل نظرية الأعداد.

## الأعداد الأولية (Prime Numbers)

في نظرية الأعداد، تُعتبر **الأعداد الأولية** من أكثر الأنواع الأساسية أهمية.

العدد الأولي هو عدد طبيعي أكبر من $1$ وله **قاسمان موجبان مختلفان فقط**:

- $1$، والعدد نفسه.

بمعنى آخر، لا يمكن كتابة العدد الأولي كحاصل ضرب عددين طبيعيين أصغر منه، باستثناء الصورة التافهة $1 \times n$.


---

### أمثلة على أعداد أولية وغير أولية

دعونا نلقي نظرة على بعض الأمثلة لتمييز الأعداد الأولية عن الأعداد المركبة:

- $2$ $\leftarrow$ $\textcolor{green}{أولي}$:
    - قواسمه: $1$ و $2$.
- $3$ $\leftarrow$ $\textcolor{green}{أولي}$:
    - قواسمه: $1$ و $3$.
- $4$ $\leftarrow$ $\textcolor{red}{غير أولي}$ (مركب):
    - قواسمه: $1$, $2$, $4$ ← أكثر من قاسمين.
- $5$ $\leftarrow$ $\textcolor{green}{أولي}$:
    - قواسمه: $1$ و $5$.
- $6$ $\leftarrow$ $\textcolor{red}{غير أولي}$ (مركب):
    - قواسمه: $1$, $2$, $3$, $6$.
- $7$ $\leftarrow$ $\textcolor{green}{أولي}$:
    - قواسمه: $1$ و $7$.
- $8$ $\leftarrow$ $\textcolor{red}{غير أولي}$ (مركب):
    - قواسمه: $1$, $2$, $4$, $8$.
- $9$ $\leftarrow$ $\textcolor{red}{غير أولي}$ (مركب):
    - قواسمه: $1$, $3$, $9$.
- $11$ $\leftarrow$ $\textcolor{green}{أولي}$:
    - قواسمه: $1$ و $11$.

---

### ملاحظات مهمة:

- العدد $1$ **ليس عددًا أوليًا**.  
  - له قاسم واحد فقط (نفسه)، ولا يحقق تعريف العدد الأولي.
- **أصغر عدد أولي** هو $2$.
  - كما أنه **العدد الزوجي الوحيد الذي يُعتبر أوليًا** — لأن كل عدد زوجي آخر يقبل القسمة على $2$ وبالتالي فهو مركب.

---